const e=JSON.parse('{"key":"v-127ed484","path":"/posts/Design%20patterns/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%9D%E6%83%B3%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%80%9D%E6%83%B3%E4%B8%8E%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E6%80%9D%E6%83%B3.html","title":"基础类型","lang":"zh-CN","frontmatter":{"date":"2021-12-01T00:00:00.000Z","title":"基础类型","icon":"tag","order":2,"category":["Design patterns"],"tag":["技术分享"],"description":"前言 假设一个场景，有一个空房间，我们要不断的往里面放一些东西。最简单的办法是把这些东西直接扔进去，bu分种类，但是时间久了，就会发现很难从这个房子里找到自己想要的东西，要调整某几样东西的位置也不容易。所以在房间里做一些柜子也许是个更好的选择，虽然柜子会增加我们的成本，但它可以在维护阶段为我们带来好处。这样也方便我们去找到相对应的东西。使用这些柜子存放东西的规则，或许就是一种模式。 定义 在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/kiki/posts/Design%20patterns/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%9D%E6%83%B3%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%80%9D%E6%83%B3%E4%B8%8E%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E6%80%9D%E6%83%B3.html"}],["meta",{"property":"og:site_name","content":"Kiki"}],["meta",{"property":"og:title","content":"基础类型"}],["meta",{"property":"og:description","content":"前言 假设一个场景，有一个空房间，我们要不断的往里面放一些东西。最简单的办法是把这些东西直接扔进去，bu分种类，但是时间久了，就会发现很难从这个房子里找到自己想要的东西，要调整某几样东西的位置也不容易。所以在房间里做一些柜子也许是个更好的选择，虽然柜子会增加我们的成本，但它可以在维护阶段为我们带来好处。这样也方便我们去找到相对应的东西。使用这些柜子存放东西的规则，或许就是一种模式。 定义 在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-07-02T01:14:42.000Z"}],["meta",{"property":"article:author","content":"Miss.Kiki"}],["meta",{"property":"article:tag","content":"技术分享"}],["meta",{"property":"article:published_time","content":"2021-12-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-07-02T01:14:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"基础类型\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-12-01T00:00:00.000Z\\",\\"dateModified\\":\\"2023-07-02T01:14:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Miss.Kiki\\",\\"url\\":\\"https://someqq.github.io/kiki/\\"}]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言-1","link":"#前言-1","children":[]},{"level":2,"title":"定义","slug":"定义-1","link":"#定义-1","children":[]},{"level":2,"title":"构成","slug":"构成","link":"#构成","children":[]},{"level":2,"title":"举例","slug":"举例","link":"#举例","children":[]},{"level":2,"title":"使用策略模式计算奖金","slug":"使用策略模式计算奖金","link":"#使用策略模式计算奖金","children":[]},{"level":2,"title":"最开始的代码","slug":"最开始的代码","link":"#最开始的代码","children":[{"level":3,"title":"缺点","slug":"缺点","link":"#缺点","children":[]}]},{"level":2,"title":"使用组合函数重构代码","slug":"使用组合函数重构代码","link":"#使用组合函数重构代码","children":[{"level":3,"title":"缺点","slug":"缺点-1","link":"#缺点-1","children":[]}]},{"level":2,"title":"使用策略模式重构代码","slug":"使用策略模式重构代码","link":"#使用策略模式重构代码","children":[{"level":3,"title":"两种方法","slug":"两种方法","link":"#两种方法","children":[]},{"level":3,"title":"模仿传统面向对象语言中的实现","slug":"模仿传统面向对象语言中的实现","link":"#模仿传统面向对象语言中的实现","children":[]},{"level":3,"title":"用JavaScript实现的策略模式","slug":"用javascript实现的策略模式","link":"#用javascript实现的策略模式","children":[]}]},{"level":2,"title":"举例","slug":"举例-1","link":"#举例-1","children":[{"level":3,"title":"表单校验","slug":"表单校验","link":"#表单校验","children":[]},{"level":3,"title":"无所考虑的解法","slug":"无所考虑的解法","link":"#无所考虑的解法","children":[]},{"level":3,"title":"策略模式思想实现","slug":"策略模式思想实现","link":"#策略模式思想实现","children":[]},{"level":3,"title":"用户是如何向Validator类发送请求","slug":"用户是如何向validator类发送请求","link":"#用户是如何向validator类发送请求","children":[]},{"level":3,"title":"Validator类的实现","slug":"validator类的实现","link":"#validator类的实现","children":[]},{"level":3,"title":"优点","slug":"优点","link":"#优点","children":[]},{"level":3,"title":"给文本输入框添加多种校验规则","slug":"给文本输入框添加多种校验规则","link":"#给文本输入框添加多种校验规则","children":[]}]},{"level":2,"title":"优点","slug":"优点-1","link":"#优点-1","children":[]},{"level":2,"title":"缺点","slug":"缺点-2","link":"#缺点-2","children":[]},{"level":2,"title":"定义","slug":"定义-2","link":"#定义-2","children":[]},{"level":2,"title":"现实中的发布-订阅模式","slug":"现实中的发布-订阅模式","link":"#现实中的发布-订阅模式","children":[]},{"level":2,"title":"DOM事件","slug":"dom事件","link":"#dom事件","children":[]},{"level":2,"title":"自定义事件","slug":"自定义事件","link":"#自定义事件","children":[]},{"level":2,"title":"发布-订阅模式的通用实现","slug":"发布-订阅模式的通用实现","link":"#发布-订阅模式的通用实现","children":[]},{"level":2,"title":"取消订阅的事件","slug":"取消订阅的事件","link":"#取消订阅的事件","children":[]},{"level":2,"title":"网站登录","slug":"网站登录","link":"#网站登录","children":[{"level":3,"title":"各模块监听登录成功的消息","slug":"各模块监听登录成功的消息","link":"#各模块监听登录成功的消息","children":[]}]},{"level":2,"title":"全局的发布-订阅对象","slug":"全局的发布-订阅对象","link":"#全局的发布-订阅对象","children":[]},{"level":2,"title":"模块间通信","slug":"模块间通信","link":"#模块间通信","children":[{"level":3,"title":"需要注意的问题","slug":"需要注意的问题","link":"#需要注意的问题","children":[]}]},{"level":2,"title":"优点","slug":"优点-2","link":"#优点-2","children":[]},{"level":2,"title":"缺点","slug":"缺点-3","link":"#缺点-3","children":[]}],"git":{"createdTime":1688200233000,"updatedTime":1688260482000,"contributors":[{"name":"guoyiqi","email":"guoyiqi@uino.com","commits":2}]},"readingTime":{"minutes":26.54,"words":7961},"filePathRelative":"posts/Design patterns/js设计模式思想之策略模式思想与发布订阅模式思想.md","localizedDate":"2021年12月1日","excerpt":"<h1> 前言</h1>\\n<p>假设一个场景，有一个空房间，我们要不断的往里面放一些东西。最简单的办法是把这些东西直接扔进去，bu分种类，但是时间久了，就会发现很难从这个房子里找到自己想要的东西，要调整某几样东西的位置也不容易。所以在房间里做一些柜子也许是个更好的选择，虽然柜子会增加我们的成本，但它可以在维护阶段为我们带来好处。这样也方便我们去找到相对应的东西。使用这些柜子存放东西的规则，或许就是一种模式。\\n<a name=\\"SDF7g\\"></a></p>\\n<h1> 定义</h1>\\n<p>在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。\\n<a name=\\"ZEBku\\"></a></p>","autoDesc":true}');export{e as data};
