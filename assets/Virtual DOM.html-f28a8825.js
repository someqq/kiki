const t=JSON.parse('{"key":"v-55292418","path":"/posts/React/Virtual%20DOM.html","title":"Virtual DOM","lang":"zh-CN","frontmatter":{"description":"Virtual DOM What 虚拟 DOM 的工作原理是通过 JS 对象模拟 DOM 的节点 Why 在 Facebook 构建 React 初期时，考虑到要提升代码抽象能力、避免人为的 DOM 操作、降低代码整体风险等因素，所以引入了虚拟 DOM。 How 虚拟 DOM 在实现上通常是 Plain Object，以 React 为例，在 render 函数中写的 JSX 会在 Babel 插件的作用下，编译为 React.createElement 执行 JSX 中的属性参数。 React.createElement 执行后会返回一个 Plain Object，它会描述自己的 tag 类型、props 属性以及 children 情况等。这些 Plain Object 通过树形结构组成一棵虚拟 DOM 树。当状态发生变更时，将变更前后的虚拟 DOM 树进行差异比较，这个过程称为 diff，生成的结果称为 patch。计算之后，会渲染 Patch 完成对真实 DOM 的操作。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/kiki/posts/React/Virtual%20DOM.html"}],["meta",{"property":"og:site_name","content":"Kiki"}],["meta",{"property":"og:title","content":"Virtual DOM"}],["meta",{"property":"og:description","content":"Virtual DOM What 虚拟 DOM 的工作原理是通过 JS 对象模拟 DOM 的节点 Why 在 Facebook 构建 React 初期时，考虑到要提升代码抽象能力、避免人为的 DOM 操作、降低代码整体风险等因素，所以引入了虚拟 DOM。 How 虚拟 DOM 在实现上通常是 Plain Object，以 React 为例，在 render 函数中写的 JSX 会在 Babel 插件的作用下，编译为 React.createElement 执行 JSX 中的属性参数。 React.createElement 执行后会返回一个 Plain Object，它会描述自己的 tag 类型、props 属性以及 children 情况等。这些 Plain Object 通过树形结构组成一棵虚拟 DOM 树。当状态发生变更时，将变更前后的虚拟 DOM 树进行差异比较，这个过程称为 diff，生成的结果称为 patch。计算之后，会渲染 Patch 完成对真实 DOM 的操作。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-07-02T01:14:42.000Z"}],["meta",{"property":"article:author","content":"Miss.Kiki"}],["meta",{"property":"article:modified_time","content":"2023-07-02T01:14:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Virtual DOM\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-07-02T01:14:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Miss.Kiki\\",\\"url\\":\\"https://someqq.github.io/kiki/\\"}]}"]]},"headers":[{"level":2,"title":"What","slug":"what","link":"#what","children":[]},{"level":2,"title":"Why","slug":"why","link":"#why","children":[]},{"level":2,"title":"How","slug":"how","link":"#how","children":[]},{"level":2,"title":"优缺点","slug":"优缺点","link":"#优缺点","children":[]}],"git":{"createdTime":1688200233000,"updatedTime":1688260482000,"contributors":[{"name":"guoyiqi","email":"guoyiqi@uino.com","commits":2}]},"readingTime":{"minutes":1.15,"words":345},"filePathRelative":"posts/React/Virtual DOM.md","localizedDate":"2023年7月1日","excerpt":"<h1> Virtual DOM</h1>\\n<h2> What</h2>\\n<p>虚拟 DOM 的<strong>工作原理</strong>是通过 JS 对象模拟 DOM 的节点</p>\\n<h2> Why</h2>\\n<p>在 Facebook 构建 React 初期时，考虑到要提升代码抽象能力、避免人为的 DOM 操作、降低代码整体风险等因素，所以引入了虚拟 DOM。</p>\\n<h2> How</h2>\\n<p>虚拟 DOM 在<strong>实现上</strong>通常是 Plain Object，以 React 为例，在 render 函数中写的 JSX 会在 Babel 插件的作用下，编译为 React.createElement 执行 JSX 中的属性参数。\\nReact.createElement 执行后会返回一个 Plain Object，它会描述自己的 tag 类型、props 属性以及 children 情况等。这些 Plain Object 通过树形结构组成一棵虚拟 DOM 树。当状态发生变更时，将变更前后的虚拟 DOM 树进行差异比较，这个过程称为 diff，生成的结果称为 patch。计算之后，会渲染 Patch 完成对真实 DOM 的操作。</p>","autoDesc":true}');export{t as data};
