import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o,c,a as r,b as e,d as l,f as a}from"./app-2d139388.js";const s={},d=a('<h1 id="渲染流程" tabindex="-1"><a class="header-anchor" href="#渲染流程" aria-hidden="true">#</a> 渲染流程</h1><h2 id="对比react16前后" tabindex="-1"><a class="header-anchor" href="#对比react16前后" aria-hidden="true">#</a> 对比React16前后</h2><p>Reconciler 模块以 React 16 为分界线分为两个版本。</p><ul><li><strong>Stack Reconciler</strong>是 React 15 及以前版本的渲染方案，其核心是以<strong>递归的方式</strong>逐级调度栈中子节点到父节点的渲染。</li><li><strong>Fiber Reconciler</strong>是 React 16 及以后版本的渲染方案，它的核心设计是<strong>增量渲染</strong>（incremental rendering），也就是将渲染工作分割为多个区块，并将其分散到多个帧中去执行。它的设计初衷是提高 React 在动画、画布及手势等场景下的性能表现。</li></ul>',4),p={href:"https://claudiopro.github.io/react-fiber-vs-stack-demo",target:"_blank",rel:"noopener noreferrer"},m=a('<p>Fiber Fiber 是一个借来的概念，在系统开发中，指一种<strong>最轻量化</strong>的线程。与一般线程不同的是，Fiber 对于系统内核是不可见的，也不能由内核进行调度。它的运行模式被称为<strong>协作式多任务</strong>，而线程采用的模式是<strong>抢占式多任务</strong>。 这有什么不同呢？</p><ul><li>在协作式多任务模式下，线程会定时放弃自己的运行权利，告知内核让下一个线程运行；</li><li>而在抢占式下，内核决定调度方案，可以直接剥夺长耗时线程的时间片，提供给其他线程。</li></ul><p>回到浏览器中，浏览器无法实现抢占式调度，那为了提升可用性与流畅度，React 在设计上只能采用合作式调度的方案：将渲染任务拆分成多段，每次只执行一段，完成后就把时间控制权交还给主线程，这就是得名 Fiber Reconciler 的原因。 在 Fiber Reconciler 还引入了两个新的概念，分别是 Fiber 与 effect。</p><ul><li>在 React Element 的基础上，通过 createFiberFromElement 函数创建 Fiber 对象。Fiber 不仅包含 React Element，还包含了指向父、子、兄弟节点的属性，保证 Fiber 构成的虚拟 DOM 树成为一个双向链表。</li><li>effect 是指在协调过程中必须执行计算的活动。</li></ul><p>有了 Fiber 的基础认知后，我们就可以进入 Fiber Reconciler 的协调过程了。</p><h2 id="调度" tabindex="-1"><a class="header-anchor" href="#调度" aria-hidden="true">#</a> 调度</h2><p>它的调度方式主要有两个特点，第一个是协作式多任务模式，在这个模式下，线程会定时放弃自己的运行权利，交还给主线程，通过requestIdleCallback 实现。第二个特点是策略优先级，调度任务通过标记 tag 的方式分优先级执行，比如动画，或者标记为 high 的任务可以优先执行。Fiber Reconciler的基本单位是 Fiber，Fiber 基于过去的 React Element 提供了二次封装，提供了指向父、子、兄弟节点的引用，为 diff 工作的双链表实现提供了基础。 在新的架构下，整个生命周期被划分为 Render 和 Commit 两个阶段。Render 阶段的执行特点是可中断、可停止、无副作用，主要是通过构造 workInProgress 树计算出 diff。以 current 树为基础，将每个 Fiber 作为一个基本单位，自下而上逐个节点检查并构造 workInProgress 树。这个过程不再是递归，而是基于循环来完成。 在执行上通过 requestIdleCallback 来调度执行每组任务，每组中的每个计算任务被称为 work，每个 work 完成后确认是否有优先级更高的 work 需要插入，如果有就让位，没有就继续。优先级通常是标记为动画或者 high 的会先处理。每完成一组后，将调度权交回主线程，直到下一次 requestIdleCallback 调用，再继续构建 workInProgress 树。 在 commit 阶段需要处理 effect 列表，这里的 effect 列表包含了根据 diff 更新 DOM 树、回调生命周期、响应 ref 等。 <img src="https://cdn.nlark.com/yuque/0/2023/png/12378710/1688194004809-90b8fe91-a5e9-4a68-a9d7-b762209babbc.png#averageHue=%23f2f4f2&amp;clientId=ue21823b1-dfc6-4&amp;from=paste&amp;height=306&amp;id=u596611ef&amp;originHeight=291&amp;originWidth=459&amp;originalType=binary&amp;ratio=0.8999999761581421&amp;rotation=0&amp;showTitle=false&amp;size=45490&amp;status=done&amp;style=none&amp;taskId=uf1198772-d488-4af7-afb3-164e2561a56&amp;title=&amp;width=483" alt="image.png" loading="lazy"></p>',7);function f(h,b){const t=n("ExternalLinkIcon");return o(),c("div",null,[d,r("p",null,[e("两者的性能差距究竟有多大呢？既然主打的是高性能场景，那么在一般的中后台页面、前端 H5 下，很难看出两者之间的性能差距。但这个 "),r("a",p,[e("demo"),l(t)]),e(" 能明显地体会到。")]),m])}const _=i(s,[["render",f],["__file","渲染流程.html.vue"]]);export{_ as default};
