const e=JSON.parse('{"key":"v-2cf7baef","path":"/posts/React/JSX.html","title":"JSX","lang":"zh-CN","frontmatter":{"description":"JSX What 按照 React 官方的解释，JSX 是一个 JavaScript 的语法扩展，或者说是一个类似于 XML 的 ECMAScript 语法扩展。它本身没有太多的语法定义，也不期望引入更多的标准。 JSX 主要用于声明 React 元素，但 React 中并不强制使用 JSX。即使使用了 JSX，也会在构建过程中，通过 Babel 插件编译为 React.createElement。所以 JSX 更像是 React.createElement 的一种语法糖。 Why 可以看出，React 团队并不想引入 JavaScript 本身以外的开发体系，而是希望通过合理的关注点分离保持组件开发的纯粹性。 因为 React 需要将组件转化为虚拟 DOM 树，所以我们在编写代码时，实际上是在手写一棵结构树。而XML 在树结构的描述上天生具有可读性强的优势。 但这样可读性强的代码仅仅是给写程序的同学看的，实际上在运行的时候，会使用 Babel 插件将 JSX 语法的代码还原为 React.createElement 的代码。 那既然可以用插件帮我们编译转换代码，那为什么不直接使用模板呢？对比其他方式: 先是模板，React 团队认为模板不应该是开发过程中的关注点，因为引入了模板语法、模板指令等概念，是一种不佳的实现方案。 其次是模板字符串，模板字符串编写的结构会造成多次内部嵌套，使整个结构变得复杂，并且优化代码提示也会变得困难重重。 最后是 JXON，同样因为代码提示困难的原因而被放弃。 所以 React 最后选用了 JSX，因为 JSX 与其设计思想贴合，不需要引入过多新的概念，对编辑器的代码提示也极为友好。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/kiki/posts/React/JSX.html"}],["meta",{"property":"og:site_name","content":"Kiki"}],["meta",{"property":"og:title","content":"JSX"}],["meta",{"property":"og:description","content":"JSX What 按照 React 官方的解释，JSX 是一个 JavaScript 的语法扩展，或者说是一个类似于 XML 的 ECMAScript 语法扩展。它本身没有太多的语法定义，也不期望引入更多的标准。 JSX 主要用于声明 React 元素，但 React 中并不强制使用 JSX。即使使用了 JSX，也会在构建过程中，通过 Babel 插件编译为 React.createElement。所以 JSX 更像是 React.createElement 的一种语法糖。 Why 可以看出，React 团队并不想引入 JavaScript 本身以外的开发体系，而是希望通过合理的关注点分离保持组件开发的纯粹性。 因为 React 需要将组件转化为虚拟 DOM 树，所以我们在编写代码时，实际上是在手写一棵结构树。而XML 在树结构的描述上天生具有可读性强的优势。 但这样可读性强的代码仅仅是给写程序的同学看的，实际上在运行的时候，会使用 Babel 插件将 JSX 语法的代码还原为 React.createElement 的代码。 那既然可以用插件帮我们编译转换代码，那为什么不直接使用模板呢？对比其他方式: 先是模板，React 团队认为模板不应该是开发过程中的关注点，因为引入了模板语法、模板指令等概念，是一种不佳的实现方案。 其次是模板字符串，模板字符串编写的结构会造成多次内部嵌套，使整个结构变得复杂，并且优化代码提示也会变得困难重重。 最后是 JXON，同样因为代码提示困难的原因而被放弃。 所以 React 最后选用了 JSX，因为 JSX 与其设计思想贴合，不需要引入过多新的概念，对编辑器的代码提示也极为友好。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-07-02T01:14:42.000Z"}],["meta",{"property":"article:author","content":"Miss.Kiki"}],["meta",{"property":"article:modified_time","content":"2023-07-02T01:14:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JSX\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-07-02T01:14:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Miss.Kiki\\",\\"url\\":\\"https://someqq.github.io/kiki/\\"}]}"]]},"headers":[{"level":2,"title":"What","slug":"what","link":"#what","children":[]},{"level":2,"title":"Why","slug":"why","link":"#why","children":[]},{"level":2,"title":"How","slug":"how","link":"#how","children":[]}],"git":{"createdTime":1688200233000,"updatedTime":1688260482000,"contributors":[{"name":"guoyiqi","email":"guoyiqi@uino.com","commits":2}]},"readingTime":{"minutes":1.96,"words":589},"filePathRelative":"posts/React/JSX.md","localizedDate":"2023年7月1日","excerpt":"<h1> JSX</h1>\\n<h2> What</h2>\\n<p>按照 React 官方的解释，<strong>JSX 是一个 JavaScript 的语法扩展，或者说是一个类似于 XML 的 ECMAScript 语法扩展</strong>。它本身没有太多的语法定义，也不期望引入更多的标准。\\nJSX 主要用于声明 React 元素，但 React 中并不强制使用 JSX。即使使用了 JSX，也会在构建过程中，通过 Babel 插件编译为 React.createElement。所以 JSX 更像是 React.createElement 的一种语法糖。</p>\\n<h2> Why</h2>\\n<p>可以看出，React 团队并不想引入 JavaScript 本身以外的开发体系，而是希望通过合理的关注点分离保持组件开发的纯粹性。\\n因为 React 需要将组件转化为虚拟 DOM 树，所以我们在编写代码时，实际上是在手写一棵结构树。而<strong>XML 在树结构的描述上天生具有可读性强的优势</strong>。\\n但这样可读性强的代码仅仅是给写程序的同学看的，实际上在运行的时候，会使用 Babel 插件将 JSX 语法的代码还原为 React.createElement 的代码。\\n那既然可以用插件帮我们编译转换代码，那为什么不直接使用模板呢？对比其他方式:\\n先是模板，React 团队认为模板不应该是开发过程中的关注点，因为引入了模板语法、模板指令等概念，是一种不佳的实现方案。\\n其次是模板字符串，模板字符串编写的结构会造成多次内部嵌套，使整个结构变得复杂，并且优化代码提示也会变得困难重重。\\n最后是 JXON，同样因为代码提示困难的原因而被放弃。\\n所以 React 最后选用了 JSX，因为 JSX 与其设计思想贴合，不需要引入过多新的概念，对编辑器的代码提示也极为友好。</p>","autoDesc":true}');export{e as data};
